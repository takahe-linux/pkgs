#!/usr/bin/env sh
#
# Satisfy a given target.
#
# Author:   Alastair Hughes
# Contact:  < hobbitalastair at yandex dot com >

set -e

#
# Define the helper functions
#

error() {
    errno="$1"
    shift
    "${rootdir}/scripts/error" $@
    exit "${errno}"
}

check_arg_numbers() {
    # Check that there are the given numbers of arguments

    if [ "$#" -lt 1 ]; then
        error 1 "check_arg_numbers requires an argument!"
    fi

    num="$1"
    shift

    if [ "$#" != "${num}" ]; then
        error 1 "Expected ${num} arguments; got '$#' ($@)"
    fi
}

#
# Main functions.
#

satisfy() {
    # Try to satisfy a given target.
    check_arg_numbers 1 $@
    local package="$1"

    local name="$(echo "${package}" | sed -e 's:.*/::')"
    local prefix="$(echo "${package}" | sed -e "s:/${name}$::")"

    if ! satisfied "${prefix}/${name}"; then

        #TODO: This is *not* infinite loop safe!
        message "Trying to satisfy ${package}"
        for dep in $(gen_depends "${prefix}" "${name}"); do
            satisfy "${dep}"
        done

        case "${prefix}" in
            toolchain) makepkg_args="-srLf" pacman_args="" \
                build_package "${prefix}" "${name}";;
            packages) makepkg_args="-dLf --nocheck" \
                pacman_args="--config ${rootdir}/pacman.conf --noconfirm" \
                build_package "${prefix}" "${name}";;
            actions) $noop || "${rootdir}/${package}";;
            targets) message "Target ${name} met!";;
            *) error 1 "Unknown package prefix '${prefix}'!";;
        esac

        message "Satisfied ${package}"
        SATISFIED="${SATISFIED} ${prefix}/${name}"
    fi
}

satisfied() {
    # Return 0 if the given prefix/name is already satisfied...
    for i in ${SATISFIED}; do
        if [ "${i}" == "$@" ]; then
            return 0
        fi
    done
    return 1
}

build_package() {
    # Build a given package with the given arguments for makepkg and pacman.
    # Usage: build_package <prefix> <name>
    # Influential variables: $pacman_args, $makepkg_args

    check_arg_numbers 2 $@

    prefix="$1"
    name="$2"

    case "${prefix}" in
        toolchain) target="local";;
        packages) target="target";;
        *) error 1 "Unknown target '${prefix}'!";;
    esac

    message "Installing ${target} package ${prefix}/${name}..."

    cd "${rootdir}/${prefix}/${name}"

    # Figure out the names of the resulting packages.
    names="$(pkgnames "${prefix}" "${name}")"

    # Rebuild if need be.
    if need_rebuild "${prefix}" "${name}" ${names}; then
        message "Rebuilding ${prefix}/${name}!"

        # Build the package
        "${noop}" || yes 'y' | makepkg --config ../makepkg.conf -cC \
            ${makepkg_args} 2> /dev/stdout || \
            error "$?" \
            "Build failed! Please check the build log for more information."
    fi

    # Install all of the resulting packages.
    # Also, keep track of the oldest package; this is used elsewhere in the
    # script, and will be until I get proper dependencies. 
    previous_package_date="0" # The timestamp on the packages...
    for pkgname in ${names}; do
        if ! "${noop}"; then
            if [ ! -e "${pkgname}" ]; then
                error 1 "Expected to find a package in '$(pwd)' called '${pkgname}'!"
            fi
            # We don't use --noconfirm because we have to install conflicting
            # packages... :(
            yes 'y' | \
                sudo pacman ${pacman_args} -U "${pkgname}" || \
                error "$?" "Failed to install package '${pkgname}'!"
        fi

        # Check the timestamp on the package...
        local package_date="$(stat -c '%Y' "${pkgname}")"
        if [ "${package_date}" -gt "${previous_package_date}" ]; then
            previous_package_date="${package_date}"
        fi
    done
}

need_rebuild() {
    # Check if a the package in the current directory needs to be rebuilt.
    # It assumes that it has been passed the names of the generated packages.
    # It will return 0 (true) if the packages need rebuilding, 1 (false) if they
    # don't.

    prefix="$1"
    name="$2"
    shift 2

    # Check that there exists an up-to-date package.
    # Check that the symlinks all exist.
    for pkgname in ${@}; do
        if [ ! -e "${pkgname}" ]; then
            message "${pkgname} does not exist!"
            return 0
        fi
    done

    # Find the youngest age of all the packages.
    local pkgdate="$(packagedate ${@})"

    # Check that the package is up to date.
    local pkgbuilddate="$(stat -c "%Y" PKGBUILD)" # The age of the PKGBUILD.
    if [ "${pkgbuilddate}" -gt "${pkgdate}" ]; then
        message "Package is out of date (${pkgbuilddate} vs ${pkgdate})!"
        return 0
    fi

    # Check that the package is newer than all the packages for its
    # dependencies.
    for dep in $(gen_depends "${prefix}" "${name}"); do
        # Check that the dep is a package dep...
        depname="$(echo "${dep}" | sed -e 's:.*/::')"
        depprefix="$(echo "${dep}" | sed -e "s:/${depname}$::")"
        if [ "${depprefix}" == 'toolchain' ] || \
            [ "${depprefix}" == 'packages' ]; then
            depdate="$(packagedate $(pkgnames "${depprefix}" "${depname}"))"
            if [ "${depdate}" -gt "${pkgdate}" ]; then
                message "Dependency ${dep} is more modern!"
                return 0
            fi
        fi
    done
    
    return 1
}

packagedate() {
    local pkgdate="$(date '+%s')" # The youngest date...
    for pkgname in ${@}; do
        # Check that a symlink exists. If not, then ignore (the package does
        # not exist??).
        if [ -e "${pkgname}" ]; then
            # Update the youngest age of the packages...
            local currentpkgdate="$(stat -c "%Y" "${pkgname}")"
            if [ "${pkgdate}" -gt "${currentpkgdate}" ]; then
                pkgdate="${currentpkgdate}"
            fi
        fi
    done
    echo "${pkgdate}"
}


satisfy $@ #> /dev/null
